# Домашнее задание к занятию "3.6. Компьютерные сети, лекция 1"

1. Сервер похоже по порту недоступен. Посмотрел с youtube. Прям псевдографику с BBS вспомнил :-)

1. Действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц всего **3**. Для стандартов с полосой 5 ГГц  всего **25** (плюс/минус).

1. MAC `38:f9:d3:55:55:79` принадлежит производителю Apple, Inc (38:F9:D3)

1. MSS будет равен в 8949 байт. `MSS = MTU - Pv4 headers – TCP headers

1. Во флагах TCP одновременно **не могут** быть установлены флаги SYN и FIN, так как служат для противоположных целей (установления и прекращения соединения соответственно). Являются однозначным указателем на вредоносную деятельность (DoS атаки)

1. В `State` присутствует только `UNCONN` так как мы атрибутом `-u` выводим только UDP (соответственно состояние отсутствия передачи данных). `TIME-WAIT` не может присутствовать так как UDP не устанавливает сессии

1.  В следующих состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере.

    | № |        | Флаг      | Клиент      | Сервер      | 
    |---|--------|:---------:|:-----------:|:-----------:|
    | 1 |        |           | ESTABLISHED | ESTABLISHED |
    | 2 | И => О | FIN       | FIN WAIT 1  | CLOSE WAIT  |
    | 3 | И <= О | ACK+FIN   | FIN WAIT 2  | LAST ACK    |
    | 4 | И => О | ACK       | TIME WAIT   | CLOSED      |
    | 5 |        |           | CLOSED      |             | 
 
1. В теории максимум соединений 2<sup>16</sup>, т.е. 65536. Исходя из формата заголовка TCP сегмента при одновременном (теоретическом) подключении клиента к серверу можно установить этот максимум (2<sup>16</sup>). В теории тоже верно и при обратном подключении. Если клиентов больше одного, ограничивающим фактором будет количество портов сервера (условно делим максимум на количество клиентов)
   
1. Ситуация при которой большое число соединений TCP на хосте находятся в состоянии `TIME-WAIT` может сложиться если за короткий промежуток было создано множество подключений (с достижением максимально возможного количества). Ситуация является штатной так как гарантирует надёжность прохождения пакетов (в случае задержек, стороны будут ждать доставки информации). В определённых ситуациях можно изменить поведение для освобождения портов (Например `SO_REUSEADDR`)

1. Как я понимаю фрагментация UDP плоха относительно фрагментации TCP тем что при потере одного фрагмента весь пакет просто не дойдёт.

1. Сначала конечно хочется гарантированной передачи (TCP). Но генерация слишком большого потока данных при отладке (умышленная или ошибочная) просто может заспамить сеть(сервер). Поэтому мой выбор комбинация (TCP и UDP). UDP для основного потока логов и TCP для контроля состояния в целом.

   Стандартно в syslog используется UDP(514), но есть RFC описывающие использование TCP(601, 6514) и UDP(6514)

1. В состоянии прослушивания на моей виртуальной машине с Ubuntu находится 5 портов TCP. Процессы которым они принадлежат:

    `rpcbind, systemd, systemd-resolve, sshd, rpcbind`

     ![Proof](https://github.com/crursus/devops-netology/blob/main/images/proof-03-sa-06-net-02.png)  

1. Для вывода `tcpdump` не только заголовков, но и содержимого фреймов в текстовом виде необходимо использовать ключ `-A`.  Для текстового и шестнадцатеричного необходимо использовать ключ `-XX`

1. Попробовал поставить штатно через, `apt install tshark` не получилось (репозитории недоступны). Установил Wireshark на хост.
   * Cобрал дамп трафика с помощью **Wireshark** на основном интерфейсе хостовой машины
   * Встретил установленные флаги Internet Protocol: `Flags: 0x40, Don't fragment`
   * Флаги бывают 
   * Стандарт Ethernet, фреймы которого попали в дамп, называется `Ethernet II`. ?
   * В дампе увидеть OUI можно в заголовке Ethernet II: `Destination: TP-Link_0f:52:57 (7c:c2:c6:0f:52:57)`
